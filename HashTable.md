## Introduction

 * Hash tables provide fast insertion, deletion, and retrieval.
 * Hash tables perform poorly for searching, eg- finding the minimum and maximum values in a data set. 
 * For searching, finding the minimum and maximum values, binary search tree is more appropriate.

## An Overview of Hashing

 * The hash table data structure is designed around an array. 
 * Each data element is stored in the array based on an associated data element called the key (generated by hash function).
 * The goal of the hash function is to attempt to distribute the keys as evenly as possible among the elements of the array.
 * Even with an efficient hash function, it is possible for two keys to hash (the result of the hash function) to the same  value. This is   called a collision, and we need a strategy for handling collisions when they occur.

> The last thing we have to determine when creating a hash function is how large an array to create for the hash table. One constraint usually placed on the array size is that it should be a prime number.

## A Hash Table Class

```javascript
function HashTable() { 
 this.table = new Array(137); 
 this.getHash = getHash; 
 this.showDistro = showDistro;                 
 this.put = put;
 this.get = get;
}
```

## Choosing a Hash Function

 * Choosing a hash function to work with string keys proves to be more difficult and should be chosen carefully.
 * A get hash function that at first glance seems to work well is to sum the ASCII value of the letters in the key.
 
```javascipt

function getHash(data) {
  var total = 0;
  for (var i = 0; i < data.length; ++i) {
    total += data.charCodeAt(i);
  }
  return total % this.table.length; 
}

function put(data) {
  var pos = this.getHash(data); 
  this.table[pos] = data;
}

function showDistro() {
  var n=0;
  for (var i = 0; i < this.table.length; ++i) {
    if (this.table[i] != undefined) {
      print(i + ": " + this.table[i]); 
    }
  } 
}

var someNames = ["David", "Jennifer", "Donnie", "Raymond", "Cynthia", "Mike", "Clayton", "Danny", "Jonathan"]; 
var hTable = new HashTable();
for (var i = 0; i < someNames.length; ++i) { 
 hTable.put(someNames[i]);
}
hTable.showDistro();

```
Here is the output:
   * 35: Cynthia
   * 45: Clayton
   * 57: Donnie
   * 77: David
   * 95: Danny
   * 116: Mike
   * 132: Jennifer
   * 134: Jonathan
    
>The getHash() function computes a hash value by summing the ASCII value of each name.
If you check in output, "Clayton" and "Raymond" hash to the same value causing collision of keys generated by getHash() function.
We need to improve our hash function to avoid such collisions, as discussed in the next section.

## A Better Hash Function

To avoid collisions, you first need to make sure the array you are using for the hash table is sized to a prime number. This is necessary due to the use of modular arithmetic in computing the key. The size of the array needs to be greater than 100 in order to more evenly disperse the keys in the table. Through experimentation, we found that the first prime number greater than 100 that didn’t cause collisions for the data set used in Example 8-1 is 137. When smaller prime numbers close to 100 were used, there were still collisions in the data set.

After properly sizing the hash table, the next step to avoiding hashing collisions is to compute a better hash value. An algorithm known as `Horner’s method` does the trick. Without getting too deep into the mathematics of the algorithm, our new hash function still works by summing the ASCII values of the characters of a string, but it adds a step by multiplying the resulting total by a prime constant. Most algorithm textbooks suggest a small prime number, such as 31, but for our set of names 31 didn’t work; however, 37 worked without causing collisions.

We now present a new, better hash function utilizing Horner’s method:

```javascript
function betterHash(string, arr) {
  const H = 37;
  var total = 0;
  for (var i = 0; i < string.length; ++i) {
    total += H * total + string.charCodeAt(i);
  }
  total = total % arr.length;
  return parseInt(total); 
}

function HashTable() { 
  this.table = new Array(137); 
  this.getHash = getHash; 
  this.betterHash = betterHash; 
  this.showDistro = showDistro; 
  this.put = put;
  this.get = get;
}

function put(data) {
  var pos = this.betterHash(data); this.table[pos] = data;
}

var someNames = ["David", "Jennifer", "Donnie", "Raymond",
"Cynthia", "Mike", "Clayton", "Danny", "Jonathan"]; var hTable = new HashTable();
for (var i = 0; i < someNames.length; ++i) { 
  hTable.put(someNames[i]);
}
htable.showDistro();

```
The result of running this program is:
    * 17: Cynthia
    * 25: Donnie
    * 30: Mike
    * 33: Jennifer
    * 37: Jonathan
    * 57: Clayton
    * 65: David
    * 66: Danny
    * 99: Raymond
All nine names are now present and accounted for.

## Hashing Integer Keys
 Now lets generate a nine-digit student identification number along with the student’s grade.

```javascript
function getRandomInt (min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function genStuData(arr) {
  for (var i = 0; i < arr.length; ++i) {
    var num = ""; 
    for(var j=1;j<=9;++j){
      num += Math.floor(Math.random() * 10);
    }
    num += getRandomInt(50, 100);
    arr[i] = num;
  }
}
```

>The `getRandomInt()` function allows us to specify a maximum and minimum random number. For a set of student grades, it is reasonable to say that the minimum grade is 50 and the maximum grade is 100.

>The `getStuData()` function generates student data. The inner loop generates the student ID number, and right after the inner loop finishes, a random grade is generated and concatenated to the student ID. Our main program will separate the ID from the grade. The hash function will total the individual digits in the student ID to compute a hash value using the `getHash()` function.

```javascript
var numStudents = 10; 
var arrSize = 97; 
var idLen = 9;
var students = new Array(numStudents); 
genStuData(students);
print ("Student data: \n");
for (var i = 0; i < students.length; ++i) {
   print(students[i].substring(0,8) + " " + students[i].substring(9));
}
print("\n\nData distribution: \n");
var hTable = new HashTable();
for (var i = 0; i < students.length; ++i) {
   hTable.put(students[i]);
}
hTable.showDistro();
```
If you run this by `getHash()` it will go in collision again, whereas `betterHash()` function found reliable.
The lesson here is obvious: `betterHash()` is the superior hashing function for strings and for integers.

